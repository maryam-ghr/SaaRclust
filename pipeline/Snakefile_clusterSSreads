from collections import defaultdict

configfile: "config.yaml"
SHORTREADS = config["shortreads"]
ALIGNERBINPATH = config["graphalignerfolder"] + "bin"
SCRIPTPATH = config["graphalignerfolder"] + "scripts"
BCALMPATH = config["bcalmpath"]
CONVERTTOGFAPATH = config["bcalm_converttoGFApath"]
BGREAT = config["bgreat"]
EXTRACTFASTQ = config["extract_fastq"]
inputDir = config["input_dir"]
softClustDir = config["soft_clust_dir"]
outputDir = config["output_dir"]
SSfastqDir = config["SS_fastq_dir"]

wildcard_constraints:
	graphname = "k\d+_a\d+_u\d+",
	k = "\d+",
	a = "\d+",
	u = "\d+",
	longnodesize = "\d+",
	overlapsize = "\d+",
	longreads = "[^_]+",
	shortreads = "[^_]+",
	lib = "[^_]+_[0-9]+"


# outout dir should have these two files: cluster_name_mapping.data and clust_partners.txt

clusters = ["V" + str(i) for i in range(1, 30)] + ["V" + str(i) for i in range(31, 48)]

sample, chunkID, = glob_wildcards(inputDir+"/{sample}_chunk{chunkID}.maf.gz")
sample=set(sample)
libs, L, = glob_wildcards(SSfastqDir + "/{lib}_L{L}_R1_001.fastq.gz")


rule all:
	input:
		#expand(SSfastqDir + "/{fastqname}_{cluster}.fastq", fastqname = [libs[i] + "_L" + L[i] + "_R1_001" for i in range(len(libs))], cluster = clusters)
		expand("graph_alignment/{fastqprefix}_R1_001_{cluster}_params_k{k}_a{a}_u{u}.data", fastqprefix=[libs[i] + "_L" + L[i] for i in range(len(libs))], cluster=clusters, k=config["k"], a = config["kmer_abundance"], u = config["unitig_abundance"])

rule add_soft_clust_to_original_map_files:
	input:
		minimap_file = inputDir+"/{sample}_chunk{chunkID}.maf.gz",
		soft_clust_file = softClustDir+"/{sample}_chunk{chunkID}_clusters.RData"
	output: outputDir+"/{sample}_chunk{chunkID}.maf"
	log: "log/add_soft_clust_{sample}_chunk{chunkID}.log"
	script: "utils/addSoftProbs.R"

rule output_header:
	input: expand(outputDir+"/{sample}_chunk{chunkID}.maf", sample=sample, chunkID=chunkID)
	output: outputDir + "/header.txt"
	log: "log/output_header.log"
	shell: "(time set +o pipefail && head -1 {input[0]} > {output})  > {log} 2>&1"

rule remove_slash_in_lib_names:
	input: outputDir+"/{sample}_chunk{chunkID}.maf",
	output: outputDir+"/{sample}_chunk{chunkID}.new.maf"
	log: "log/remove_slash_in_lib_names_{sample}_chunk{chunkID}.log"
	shell: "(time tail -n +2 {input} | awk '{{sub(/.{{1}}/, \"\", $3)}}1' > {output}) > {log} 2>&1"

rule split_chunk_by_lib:
	input:
		minimap_file = outputDir+"/{sample}_chunk{chunkID}.new.maf"
	output: [outputDir+"/splitted-per-lib/{sample}_chunk{chunkID}_" + x for x in expand("{lib}.maf", lib=libs)],
	log: "log/split_chunk_by_lib_{sample}_chunk{chunkID}"
	shell: "(time awk '{{print>\"{outputDir}/splitted-per-lib/{wildcards.sample}_chunk{wildcards.chunkID}_\"$3\".maf\"}}' {input.minimap_file} && touch {output}) > {log} 2>&1"

rule merge_files_with_same_lib:
	input: [outputDir + x + "{lib}.maf" for x in expand("/splitted-per-lib/{sample}_chunk{chunkID}_", sample=sample, chunkID=chunkID)]
	output: outputDir+"/splitted-per-lib/aln_{lib}.maf"
	log: "log/merge_files_with_same_lib_{lib}.log"
	shell: "(time cat {input} > {output}) > {log} 2>&1"

rule sort_lib_alignments:
	input:
		header = outputDir + "/header.txt",
		splittedChunks = [outputDir + x + "{lib}.maf" for x in expand("/splitted-per-lib/{sample}_chunk{chunkID}_", sample=sample, chunkID=chunkID)],
		libAlignment = outputDir+"/splitted-per-lib/aln_{lib}.maf"
	output: outputDir+"/splitted-per-lib/aln_{lib}_sorted.maf"
	log: "log/sort_lib_alignments_{lib}.log"
	shell: "(time cat {input.header} > {output} && sort -k1,1 {input.libAlignment} >> {output}) > {log} 2>&1"

rule cluster_SS_reads:
	input:
		aln_lib = outputDir+"/splitted-per-lib/aln_{lib}_sorted.maf",
		clust_to_chrom_mapping = outputDir + "/cluster_name_mapping.data",
		cluster_pairs = outputDir + "/clust_partners.txt"
	output: outputDir+"/splitted-per-lib/clust_{lib}.data"
	log: "log/cluster_SS_reads_{lib}.log"
	script: "utils/cluster_SS_reads.snakemake.R"

rule split_SS_read_names_by_clust:
	input: outputDir+"/splitted-per-lib/clust_{lib}.data"
	output: expand(outputDir+"/splitted-per-lib/clust_splitted_{{lib}}_{cluster}.data", cluster=clusters)
	log: "log/split_SS_read_names_by_clust_{lib}.log"
	shell: "(time awk -F, '{{if ($2 != \"\")print $1> \"{outputDir}/splitted-per-lib/clust_splitted_\" $3 \"_\" $2 \".data\"}}' {input}) > {log} 2>&1"

rule extract_fastq_per_lib_per_clust:
	input:
		SS_read_names = outputDir+"/splitted-per-lib/clust_splitted_{lib}_{cluster}.data",
		SS_fastq = SSfastqDir + "/{lib}_L{L}_R1_001.fastq.gz"
	output: SSfastqDir + "/{lib}_L{L}_R1_001_{cluster}.fastq"	
	log: "log/extract_fastq_per_lib_per_clust.log_{lib}_{L}_{cluster}"
	shell: "(time {EXTRACTFASTQ} {input} > {output}) > {log} 2>&1"

