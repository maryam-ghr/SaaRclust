import os
import subprocess
import zipfile


#TODO list for assembly

#For Peter's assembly pipeline, there should be separate fastq files files per chrom/haplo (in total 46)
#/scratch/bioinf/projects/diploid-genome-assembly/pebert/test_ont/run_folder/output/diploid_assembly/strandseq_split/longshot_QUAL10_GQ100/HG00733_sra_pbsq1-clr_1000_scV7-shasta/HG00733_sra_pbsq1-clr_1000/HG00733_1kg_il25k-npe_sseq/draft/haploid_fastq

#Splitting the fastq file into clusters:
#1- split your long read phase table per cluster --> (chrom/dir)
#2- split it into 92 separate fastq files by wahtshap split --> (chrom/dir/haplo)
#3- correct the orientation of the backward clusters, and merge them with their paired file


configfile: "config_assembly.yaml"
#SHORTREADS = config["shortreads"]
#ALIGNERBINPATH = config["graphalignerfolder"]
GRAPHPATH = config["graphfolder"]
#SCRIPTPATH = config["graphalignerfolder"] + "scripts"
#BCALMPATH = config["bcalmpath"]
#CONVERTTOGFAPATH = config["bcalm_converttoGFApath"]
#BGREAT = config["bgreat"]
#EXTRACTFASTQ = config["extract_fastq"]
#inputDir = config["input_dir"]
#softClustDir = config["soft_clust_dir"]
#outputDir = "output"#config["output_dir"]
SSfastqDir = config["SS_fastq_dir"]
SSbamDir = config["SS_bam_dir"]
#VG = config["VG"]
#nodelens = config["node_lens"]
chroms = ["chr" + str(x) for x in range(1, 23)]# + ["chrX"]
#exportFasta = config["export_fasta_path"]
#computeSimpleBubble = config["simple_bubble_detection_path"]
#getSNVbubbles = config["get_snv_bubbles_path"]
#getRevcompFree = config["get_rev_comp_free_path"]
#clustersizes = config["cluster_sizes"]
phasedSSvcfDir = config["phased_vcf_dir"]
whatshap = config["whatshap"]
PBbamDir = config["pb_bam_dir"]
minPBlen = config["min_pb_len"]
#platinumVCFdir = config["platinum_vcf_dir"]
N = config["Nchunks"]
l = len(str(N))
chunkID = ['0'*(l-len(str(i)))+str(i) for i in range(N)]
#chunkID = ['000']
sample = config["sample"]
w = config["w"]
#w="-default"
kMinimap = config["k_minimap"]
fMinimap = config["f"]
z = config["z"]
outputfolder    = "SaaRclust_results"
haplotypes = ['H1', 'H2']

#####################################################################
###### getting clusters
clust_pairs_file = "aligns_k" + str(kMinimap) + "_w" + str(w) + "_f" + str(fMinimap) + "_z" + str(z) + "/SaaRclust_results_" + sample + "/clust_partners.txt"
clusters = []
clust_pairs = []
with open(clust_pairs_file) as f:
	next(f)
	for line in f:
		if line=="":
			continue

		sp = line.split()
		clust1, clust2 = sp[1], sp[2]
		min_clust, max_clust = min(clust1, clust2), max(clust1, clust2)
		clust_pair = min_clust + '_' + max_clust
		
		clusters.append(clust1)
		if clust1 == min_clust:
			clust_pairs.append(clust_pair)

print('clusters =', clusters)
print('clust_pairs =', clust_pairs)


#####################################################################

wildcard_constraints:
	clust = "[V]\d+",


rule all:
	input:
		expand("assembly/splitted_fastq/cluster{clust}_{haplo}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.fastq.gz", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample, clust=clusters, haplo=haplotypes),
		expand("assembly/splitted_fastq_clust_pair/{clustpair}_{haplo}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.fastq.gz", k=config["k"], a = config["kmer_abundance"], l = config["l"], kMinimap=kMinimap, w=w, f=fMinimap, z=z, sample=sample, clustpair=clust_pairs, haplo=haplotypes)

rule output_soft_clust_in_long_reads:
	input:
		soft_clust_file = "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/{sample}_chunk{chunks}_clusters.RData"
	output: "aligns_k{kMinimap}_w{w}_f{f}_z{z}/"+outputfolder+"_{sample}/Clusters/soft_clusters_long_reads_chunk{chunks}.data"
	log: "log/output_soft_clust_in_long_reads_{sample}_k{kMinimap}_w{w}_f{f}_z{z}_chunk{chunks}.log"
	script: "utils/outputSoftProbs.R"


rule split_phase_file_by_clust:
	input:
		phase_files=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/phased_long_reads/iteration2_pb_phase_chunk{chunks}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.data", chunks=chunkID),
		clust_files=expand("aligns_k{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}/"+outputfolder+"_{{sample}}/Clusters/soft_clusters_long_reads_chunk{chunks}.data", chunks=chunkID)
	output: expand("assembly/haplotype_lists/cluster{clust}_iteration2_pb_phase_kMinimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.data", clust=clusters)
	log: "log/ split_phase_file_by_clust_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.log"
	script: "utils/split_phased_long_reads_by_cluster.snakemake.py"


rule whatshap_split:
	input:
		fastq=PBbamDir+"/{sample}.fastq.gz",
		haplo_list="assembly/haplotype_lists/cluster{clust}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.data"
	output:
		splitted=expand("assembly/splitted_fastq/cluster{{clust}}_{haplo}_iteration2_pb_phase_kMinimap{{kMinimap}}_w{{w}}_f{{f}}_z{{z}}_k{{k}}_a{{a}}_l{{l}}_{{sample}}.fastq.gz", haplo=haplotypes)
	log: "log/whatshap_split_{clust}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.log"
	shell: "(time {whatshap} split {input.fastq} {input.haplo_list} --output-h1 {output[0]} --output-h2 {output[1]} --discard-unknown-reads) > {log} 2>&1"



rule merge_clustpairs_fastq:
	input: lambda wc: ["assembly/splitted_fastq/cluster{}_{}_iteration2_pb_phase_kMinimap{}_w{}_f{}_z{}_k{}_a{}_l{}_{}.fastq.gz".format(clust, wc.haplo, wc.kMinimap, wc.w, wc.f, wc.z, wc.k, wc.a, wc.l, wc.sample) for clust in wc.clustpair.split('_')]
	output: "assembly/splitted_fastq_clust_pair/{clustpair}_{haplo}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.fastq.gz"
	log: "log/merge_clustpairs_fastq_{clustpair}_{haplo}_iteration2_pb_phase_kMinimap{kMinimap}_w{w}_f{f}_z{z}_k{k}_a{a}_l{l}_{sample}.log"
	shell:
		'''
		(time zcat {input[0]} > {output} &&
		zcat {input[1]} | bioawk -c fastx '{{print \"@\"$name; print revcomp($seq); print \"+\"; print $qual}}' >> {output} &&
		gzip {output}) > {log} 2>&1
		'''

